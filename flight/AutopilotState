import numpy as np

#
class State:
	CONST_GRAVITY = 9.8
	CONST_E3 = np.matrix('0;0;1')

	#creates a new state object, taking pitch, roll, and yaw in degrees
	def __init__(self, theta = 0.0, phi = 0.0, psi = 0.0, k = 1):
		self.theta = theta  #pitch
		self.phi = phi 		#roll
		self.psi = psi		#yaw
		self.omega = [np.matrix('0;0;0')]
		self.R = self.attitude_matrix()
		self.k = k

	def set_k(k):
		self.k = k

	def get_R():
		return R

	#The method which updates and returns the updated rotation matrix. Takes an acceleration vector and angular momentum vector as arguments
	def update_R(a, omega):
		b = (-k)*sigma_r(a)
		R = np.dot(R, omega - b + sigma_r(a))
		return R 

	#b_hat is the same as sigma_b
	def b_hat(k_I, sigma_r):
		return sigma_b(k_I, sigma_r)

	def sigma_b(k_I, sigma_r):
		return k_I*sigma_r;

	#based on equation 4 from the mahoney paper
	def sigma_r(a):
		u_b = a / CONST_GRAVITY
		ku = k * u_b
		ru = np.dot(R.getT(), CONST_E3)
		return np.cross(ku,ru)

	#Generates the sigma sub r vector used to get the new position. k, vb, and vi should be lists of the same length
	def sigma_r(k, vb, vi):
		return_vector = np.matrix('0;0;0')
		i = 0
		for koefficient in k:
			return_vector += koefficient*np.dot(np.cross(vb[i],attitude_matrix().getT()),vi[i])
		return return_vector



	#converts a vector to a matrix so we can manipulate it with matrix muliplication
	def vector_to_matrix(vector):
		return np.matrix('vector[0]; vector[1]; vector[2]')

	#gives a vector from a matrix (not sure if this works)
	def matrix_to_vector(matrix):
		return matrix.getT.take([0,1,2])

	def test_print():
		print attitude_matrix()



	def attitude_matrix(self): #gives the attitude matrix R (DOUBLE CHECK ALL THE TRIG OPERATIONS!!!!!)
		cT = np.cos(self.theta)
		sT = np.sin(self.theta)
		cPhi = np.cos(self.phi)
		sPhi = np.sin(self.phi)
		cPsi = np.cos(self.psi)
		sPsi = np.sin(self.psi)

		a1 = (cT*cPsi)
		a2 = (sPhi*sT*cPsi-cPhi*sPsi)
		a3 = (cPhi*sT*cPsi+sPhi*sPsi)

		b1 = cT*sPhi
		b2 = sPsi*sT*sPhi+cPsi*cPhi
		b3 = cPsi*sT*sPhi-sPsi*cPhi

		c1 = (-sT)
		c2 = sPhi*cT
		c3 = cPhi*cT

		return  np.matrix('a1 a2 a3; b1 b2 b3; c1 c2 c3')



test_state = State(1, 1, 1, 1)
print test_state.attitude_matrix()

