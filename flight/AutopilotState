import numpy as np



class State:
	CONST_GRAVITY = 9.8
	CONST_E3 = np.matrix(((0),(0),(1))).getT()

	#creates a new state object, taking pitch, roll, and yaw in degrees
	def __init__(self, psi = 0.0, theta = 0.0, phi = 0.0, k = 1):
		self.theta = theta  #pitch
		self.phi = phi 		#roll
		self.psi = psi		#yaw
		self.omega = [np.matrix(((0),(0),(0)))]
		self.R = self.attitude_matrix()
		self.k = k

	def set_k(k):
		self.k = k

	def get_R():
		return R

	#The method which updates and returns the updated rotation matrix. Takes an acceleration vector and angular momentum vector as arguments
	def update_R(self, a, omega):
		b = self.sigma_r(a)*(-self.k)
		self.R = cross_product_matrix(np.dot(self.R, omega - b + self.sigma_r(a)))
		return self.R 

	#b_hat is the same as sigma_b
	def b_hat(k_I, sigma_r):
		return sigma_b(k_I, sigma_r)

	def sigma_b(k_I, sigma_r):
		return k_I*self.sigma_r;

	#based on equation 4 from the mahoney paper
	def sigma_r(self, a):
		CONST_GRAVITY = 9.8
		CONST_E3 = np.matrix(((0),(0),(1))).getT()
		u_b = a / CONST_GRAVITY
		ku = self.k * u_b
		ru = np.dot(self.R.getT(), CONST_E3)
		print ku
		print ru
		return np.matrix(np.cross(ku.getT(),ru.getT())).getT()

	#Generates the sigma sub r vector used to get the new position. k, vb, and vi should be lists of the same length
	#def sigma_r(k, vb, vi):
	#	return_vector = np.matrix(((0),(0),(0)))
	#	i = 0
	#	for koefficient in k:
	#		return_vector += koefficient*np.dot(np.cross(vb[i],attitude_matrix().getT()),vi[i])
	#	return return_vector



	#converts a vector to a matrix so we can manipulate it with matrix muliplication (untested)
	def vector_to_matrix(vector):
		return np.matrix(( (vector[0]), (vector[1],) (vector[2])))

	#gives a vector from a matrix (untested)
	def matrix_to_vector(matrix):
		return matrix.getT.take([0,1,2])

	def test_print():
		print attitude_matrix()



	def attitude_matrix(self): #gives the attitude matrix R (DOUBLE CHECK ALL THE TRIG OPERATIONS!!!!!)
		cT = np.cos(self.theta)
		sT = np.sin(self.theta)
		cPhi = np.cos(self.phi)
		sPhi = np.sin(self.phi)
		cPsi = np.cos(self.psi)
		sPsi = np.sin(self.psi)

		a1 = (cT*cPsi)
		a2 = (sPhi*sT*cPsi-cPhi*sPsi)
		a3 = (cPhi*sT*cPsi+sPhi*sPsi)

		b1 = cT*sPhi
		b2 = sPsi*sT*sPhi+cPsi*cPhi
		b3 = cPsi*sT*sPhi-sPsi*cPhi

		c1 = (-sT)
		c2 = sPhi*cT
		c3 = cPhi*cT

		return  np.matrix( ( (a1,a2,a3), (b1, b2, b3), (c1, c2, c3) ) )

#returns the skew-symmetric matrix that represents the cross product with the given vector
def cross_product_matrix(vector):
	return np.matrix(( (0,-vector[2],vector[1]),(vector[2],0,-vector[0]),(-vector[1],vector[0],0)))



test_state = State(1, 1, 1, 1)
print test_state.attitude_matrix()
print test_state.get_R
acceleration = np.matrix(((1),(1),(1))).getT()
angular = np.matrix(((1),(1),(1))).getT()
print test_state.update_R(acceleration,angular)
print 1
acceleration = np.matrix(((1),(1),(1))).getT()
angular = np.matrix(((1),(1),(1))).getT()
print test_state.update_R(acceleration,angular)
print 2
print test_state.update_R(acceleration,angular)